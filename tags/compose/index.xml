<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compose on Hello Bibo</title>
    <link>https://bibo19842003.github.io/tags/compose/</link>
    <description>Recent content in Compose on Hello Bibo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>bibo19842003@163.com (bibo)</managingEditor>
    <webMaster>bibo19842003@163.com (bibo)</webMaster>
    <lastBuildDate>Thu, 28 Mar 2019 15:07:20 +0800</lastBuildDate>
    <atom:link href="https://bibo19842003.github.io/tags/compose/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker compose</title>
      <link>https://bibo19842003.github.io/docker/docker-compose/</link>
      <pubDate>Thu, 28 Mar 2019 15:07:20 +0800</pubDate>
      <author>bibo19842003@163.com (bibo)</author>
      <guid>https://bibo19842003.github.io/docker/docker-compose/</guid>
      <description>

&lt;h2 id=&#34;compose-简介:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;Compose 简介&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 &lt;code&gt;OpenStack&lt;/code&gt; 中的 &lt;code&gt;Heat&lt;/code&gt; 十分类似。&lt;/p&gt;

&lt;p&gt;其代码目前在 &lt;a href=&#34;https://github.com/docker/compose&#34;&gt;https://github.com/docker/compose&lt;/a&gt; 上开源。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。&lt;/p&gt;

&lt;p&gt;通过第一部分中的介绍，我们知道使用一个 &lt;code&gt;Dockerfile&lt;/code&gt; 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 恰好满足了这样的需求。它允许用户通过一个单独的 &lt;code&gt;docker-compose.yml&lt;/code&gt; 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 中有两个重要的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务 (&lt;code&gt;service&lt;/code&gt;)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;项目 (&lt;code&gt;project&lt;/code&gt;)：由一组关联的应用容器组成的一个完整业务单元，在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件中定义。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 &lt;code&gt;Compose&lt;/code&gt; 来进行编排管理。&lt;/p&gt;

&lt;h2 id=&#34;安装与卸载:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;安装与卸载&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 支持 Linux、macOS、Windows 10 三大平台。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 可以通过 Python 的包管理工具 &lt;code&gt;pip&lt;/code&gt; 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。&lt;/p&gt;

&lt;p&gt;前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Docker for Mac&lt;/code&gt; 、&lt;code&gt;Docker for Windows&lt;/code&gt; 自带 &lt;code&gt;docker-compose&lt;/code&gt; 二进制文件，安装 Docker 之后可以直接使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose --version

docker-compose version 1.17.1, build 6d101fb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux 系统请使用以下介绍的方法安装。&lt;/p&gt;

&lt;h3 id=&#34;二进制包:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;二进制包&lt;/h3&gt;

&lt;p&gt;在 Linux 上的也安装十分简单，从 &lt;a href=&#34;https://github.com/docker/compose/releases&#34;&gt;官方 GitHub Release&lt;/a&gt; 处直接下载编译好的二进制文件即可。&lt;/p&gt;

&lt;p&gt;例如，在 Linux 64 位系统上直接下载对应的二进制包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pip-安装:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;PIP 安装&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;注：&lt;/em&gt; &lt;code&gt;x86_64&lt;/code&gt; 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 &lt;code&gt;ARM&lt;/code&gt; (例如，树莓派)，再使用 &lt;code&gt;pip&lt;/code&gt; 安装。&lt;/p&gt;

&lt;p&gt;这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。&lt;/p&gt;

&lt;p&gt;执行安装命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pip install -U docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到类似如下输出，说明安装成功。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Collecting docker-compose
  Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded
...
Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bash-补全命令:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;bash 补全命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose &amp;gt; /etc/bash_completion.d/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;容器中执行:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;容器中执行&lt;/h3&gt;

&lt;p&gt;Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &amp;gt; /usr/local/bin/docker-compose
$ chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，查看下载的 &lt;code&gt;run.sh&lt;/code&gt; 脚本内容，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;set -e

VERSION=&amp;quot;1.8.0&amp;quot;
IMAGE=&amp;quot;docker/compose:$VERSION&amp;quot;


# Setup options for connecting to docker host
if [ -z &amp;quot;$DOCKER_HOST&amp;quot; ]; then
    DOCKER_HOST=&amp;quot;/var/run/docker.sock&amp;quot;
fi
if [ -S &amp;quot;$DOCKER_HOST&amp;quot; ]; then
    DOCKER_ADDR=&amp;quot;-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST&amp;quot;
else
    DOCKER_ADDR=&amp;quot;-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH&amp;quot;
fi


# Setup volume mounts for compose config and context
if [ &amp;quot;$(pwd)&amp;quot; != &#39;/&#39; ]; then
    VOLUMES=&amp;quot;-v $(pwd):$(pwd)&amp;quot;
fi
if [ -n &amp;quot;$COMPOSE_FILE&amp;quot; ]; then
    compose_dir=$(dirname $COMPOSE_FILE)
fi
# TODO: also check --file argument
if [ -n &amp;quot;$compose_dir&amp;quot; ]; then
    VOLUMES=&amp;quot;$VOLUMES -v $compose_dir:$compose_dir&amp;quot;
fi
if [ -n &amp;quot;$HOME&amp;quot; ]; then
    VOLUMES=&amp;quot;$VOLUMES -v $HOME:$HOME -v $HOME:/root&amp;quot; # mount $HOME in /root to share docker.config
fi

# Only allocate tty if we detect one
if [ -t 1 ]; then
    DOCKER_RUN_OPTIONS=&amp;quot;-t&amp;quot;
fi
if [ -t 0 ]; then
    DOCKER_RUN_OPTIONS=&amp;quot;$DOCKER_RUN_OPTIONS -i&amp;quot;
fi

exec docker run --rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w &amp;quot;$(pwd)&amp;quot; $IMAGE &amp;quot;$@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，它其实是下载了 &lt;code&gt;docker/compose&lt;/code&gt; 镜像并运行。&lt;/p&gt;

&lt;h3 id=&#34;卸载:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;卸载&lt;/h3&gt;

&lt;p&gt;如果是二进制包方式安装的，删除二进制文件即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo rm /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是通过 &lt;code&gt;pip&lt;/code&gt; 安装的，则执行如下命令即可删除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pip uninstall docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;术语:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;术语&lt;/h3&gt;

&lt;p&gt;首先介绍几个术语。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务 (&lt;code&gt;service&lt;/code&gt;)：一个应用容器，实际上可以运行多个相同镜像的实例。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;项目 (&lt;code&gt;project&lt;/code&gt;)：由一组关联的应用容器组成的一个完整业务单元。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，一个项目可以由多个服务（容器）关联而成，&lt;code&gt;Compose&lt;/code&gt; 面向项目进行管理。&lt;/p&gt;

&lt;h3 id=&#34;场景:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;场景&lt;/h3&gt;

&lt;p&gt;最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。&lt;/p&gt;

&lt;p&gt;下面我们用 &lt;code&gt;Python&lt;/code&gt; 来建立一个能够记录页面访问次数的 web 网站。&lt;/p&gt;

&lt;h4 id=&#34;web-应用:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;web 应用&lt;/h4&gt;

&lt;p&gt;新建文件夹，在该目录中编写 &lt;code&gt;app.py&lt;/code&gt; 文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host=&#39;redis&#39;, port=6379)

@app.route(&#39;/&#39;)
def hello():
    count = redis.incr(&#39;hits&#39;)
    return &#39;Hello World! 该页面已被访问 {} 次。\n&#39;.format(count)

if __name__ == &amp;quot;__main__&amp;quot;:
    app.run(host=&amp;quot;0.0.0.0&amp;quot;, debug=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dockerfile:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;Dockerfile&lt;/h4&gt;

&lt;p&gt;编写 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，内容为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM python:3.6-alpine
ADD . /code
WORKDIR /code
RUN pip install redis flask
CMD [&amp;quot;python&amp;quot;, &amp;quot;app.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;docker-compose-yml:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;docker-compose.yml&lt;/h4&gt;

&lt;p&gt;编写 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件，这个是 Compose 使用的主模板文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;3&#39;
services:

  web:
    build: .
    ports:
     - &amp;quot;5000:5000&amp;quot;

  redis:
    image: &amp;quot;redis:alpine&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;运行-compose-项目:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;运行 compose 项目&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时访问本地 &lt;code&gt;5000&lt;/code&gt; 端口，每次刷新页面，计数就会加 1。&lt;/p&gt;

&lt;h2 id=&#34;compose-命令说明:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;Compose 命令说明&lt;/h2&gt;

&lt;h3 id=&#34;命令对象与格式:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;命令对象与格式&lt;/h3&gt;

&lt;p&gt;对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。&lt;/p&gt;

&lt;p&gt;执行 &lt;code&gt;docker-compose [COMMAND] --help&lt;/code&gt; 或者 &lt;code&gt;docker-compose help [COMMAND]&lt;/code&gt; 可以查看具体某个命令的使用格式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker-compose&lt;/code&gt; 命令的基本的使用格式是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose [-f=&amp;lt;arg&amp;gt;...] [options] [COMMAND] [ARGS...]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;命令选项:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;命令选项&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-f, --file FILE&lt;/code&gt; 指定使用的 Compose 模板文件，默认为 &lt;code&gt;docker-compose.yml&lt;/code&gt;，可以多次指定。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-p, --project-name NAME&lt;/code&gt; 指定项目名称，默认将使用所在目录名称作为项目名。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--x-networking&lt;/code&gt; 使用 Docker 的可拔插网络后端特性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--x-network-driver DRIVER&lt;/code&gt; 指定网络后端的驱动，默认为 &lt;code&gt;bridge&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--verbose&lt;/code&gt; 输出更多调试信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-v, --version&lt;/code&gt; 打印版本并退出。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命令使用说明:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;命令使用说明&lt;/h3&gt;

&lt;h4 id=&#34;build:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose build [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;构建（重新构建）项目中的服务容器。&lt;/p&gt;

&lt;p&gt;服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。&lt;/p&gt;

&lt;p&gt;可以随时在项目目录下运行 &lt;code&gt;docker-compose build&lt;/code&gt; 来重新构建服务。&lt;/p&gt;

&lt;p&gt;选项包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--force-rm&lt;/code&gt; 删除构建过程中的临时容器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--no-cache&lt;/code&gt; 构建镜像过程中不使用 cache（这将加长构建过程）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--pull&lt;/code&gt; 始终尝试通过 pull 来获取更新版本的镜像。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;config:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;config&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。&lt;/p&gt;

&lt;h4 id=&#34;down:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;down&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;此命令将会停止 &lt;code&gt;up&lt;/code&gt; 命令所启动的容器，并移除网络&lt;/p&gt;

&lt;h4 id=&#34;exec:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;进入指定的容器。&lt;/p&gt;

&lt;h4 id=&#34;help:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;help&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;获得一个命令的帮助。&lt;/p&gt;

&lt;h4 id=&#34;images:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;images&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;列出 Compose 文件中包含的镜像。&lt;/p&gt;

&lt;h4 id=&#34;kill:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose kill [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过发送 &lt;code&gt;SIGKILL&lt;/code&gt; 信号来强制停止服务容器。&lt;/p&gt;

&lt;p&gt;支持通过 &lt;code&gt;-s&lt;/code&gt; 参数来指定发送的信号，例如通过如下指令发送 &lt;code&gt;SIGINT&lt;/code&gt; 信号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose kill -s SIGINT
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;logs:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;logs&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose logs [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 &lt;code&gt;--no-color&lt;/code&gt; 来关闭颜色。&lt;/p&gt;

&lt;p&gt;该命令在调试问题的时候十分有用。&lt;/p&gt;

&lt;h4 id=&#34;pause:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;pause&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose pause [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;暂停一个服务容器。&lt;/p&gt;

&lt;h4 id=&#34;port:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;port&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose port [options] SERVICE PRIVATE_PORT&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;打印某个容器端口所映射的公共端口。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--protocol=proto&lt;/code&gt; 指定端口协议，tcp（默认值）或者 udp。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--index=index&lt;/code&gt; 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ps:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;ps&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose ps [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;列出项目中目前的所有容器。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-q&lt;/code&gt; 只打印容器的 ID 信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pull:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;pull&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose pull [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;拉取服务依赖的镜像。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--ignore-pull-failures&lt;/code&gt; 忽略拉取镜像过程中的错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;push:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;推送服务依赖的镜像到 Docker 镜像仓库。&lt;/p&gt;

&lt;h4 id=&#34;restart:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;restart&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose restart [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;重启项目中的服务。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 指定重启前停止容器的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rm:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;rm&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose rm [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;删除所有（停止状态的）服务容器。推荐先执行 &lt;code&gt;docker-compose stop&lt;/code&gt; 命令来停止容器。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-f, --force&lt;/code&gt; 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; 删除容器所挂载的数据卷。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;run:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在指定服务上执行一个命令。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run ubuntu ping docker.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将会启动一个 ubuntu 服务容器，并执行 &lt;code&gt;ping docker.com&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。&lt;/p&gt;

&lt;p&gt;该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。&lt;/p&gt;

&lt;p&gt;两个不同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;给定命令将会覆盖原有的自动运行命令；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不会自动创建端口，以避免冲突。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不希望自动启动关联的容器，可以使用 &lt;code&gt;--no-deps&lt;/code&gt; 选项，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run --no-deps web python manage.py shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将不会启动 web 容器所关联的其它容器。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 后台运行容器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--name NAME&lt;/code&gt; 为容器指定一个名字。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--entrypoint CMD&lt;/code&gt; 覆盖默认的容器启动指令。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-e KEY=VAL&lt;/code&gt; 设置环境变量值，可多次使用选项来设置多个环境变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-u, --user=&amp;quot;&amp;quot;&lt;/code&gt; 指定运行容器的用户名或者 uid。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--no-deps&lt;/code&gt; 不自动启动关联的服务容器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--rm&lt;/code&gt; 运行命令后自动删除容器，&lt;code&gt;d&lt;/code&gt; 模式下将忽略。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-p, --publish=[]&lt;/code&gt; 映射容器端口到本地主机。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--service-ports&lt;/code&gt; 配置服务端口并映射到本地主机。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-T&lt;/code&gt; 不分配伪 tty，意味着依赖 tty 的指令将无法运行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;scale:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose scale [options] [SERVICE=NUM...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;设置指定服务运行的容器个数。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;service=num&lt;/code&gt; 的参数来设置数量。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose scale web=3 db=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。&lt;/p&gt;

&lt;p&gt;一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;start:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose start [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;启动已经存在的服务容器。&lt;/p&gt;

&lt;h4 id=&#34;stop:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose stop [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;停止已经处于运行状态的容器，但不删除它。通过 &lt;code&gt;docker-compose start&lt;/code&gt; 可以再次启动这些容器。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;top:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;top&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;查看各个服务容器内运行的进程。&lt;/p&gt;

&lt;h4 id=&#34;unpause:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;unpause&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose unpause [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;恢复处于暂停状态中的服务。&lt;/p&gt;

&lt;h4 id=&#34;up:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;up&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose up [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。&lt;/p&gt;

&lt;p&gt;链接的服务都将会被自动启动，除非已经处于运行状态。&lt;/p&gt;

&lt;p&gt;可以说，大部分时候都可以直接通过该命令来启动一个项目。&lt;/p&gt;

&lt;p&gt;默认情况，&lt;code&gt;docker-compose up&lt;/code&gt; 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。&lt;/p&gt;

&lt;p&gt;当通过 &lt;code&gt;Ctrl-C&lt;/code&gt; 停止命令时，所有容器将会停止。&lt;/p&gt;

&lt;p&gt;如果使用 &lt;code&gt;docker-compose up -d&lt;/code&gt;，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。&lt;/p&gt;

&lt;p&gt;默认情况，如果服务容器已经存在，&lt;code&gt;docker-compose up&lt;/code&gt; 将会尝试停止容器，然后重新创建（保持使用 &lt;code&gt;volumes-from&lt;/code&gt; 挂载的卷），以保证新启动的服务匹配 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 &lt;code&gt;docker-compose up --no-recreate&lt;/code&gt;。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 &lt;code&gt;docker-compose up --no-deps -d &amp;lt;SERVICE_NAME&amp;gt;&lt;/code&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 在后台运行服务容器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--no-color&lt;/code&gt; 不使用颜色来区分不同的服务的控制台输出。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--no-deps&lt;/code&gt; 不启动服务所链接的容器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--force-recreate&lt;/code&gt; 强制重新创建容器，不能与 &lt;code&gt;--no-recreate&lt;/code&gt; 同时使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--no-recreate&lt;/code&gt; 如果容器已经存在了，则不重新创建，不能与 &lt;code&gt;--force-recreate&lt;/code&gt; 同时使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--no-build&lt;/code&gt; 不自动构建缺失的服务镜像。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;version:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;格式为 &lt;code&gt;docker-compose version&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;打印版本信息。&lt;/p&gt;

&lt;h2 id=&#34;compose-模板文件:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;Compose 模板文件&lt;/h2&gt;

&lt;p&gt;模板文件是使用 &lt;code&gt;Compose&lt;/code&gt; 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 &lt;code&gt;docker run&lt;/code&gt; 相关参数的含义都是类似的。&lt;/p&gt;

&lt;p&gt;默认的模板文件名称为 &lt;code&gt;docker-compose.yml&lt;/code&gt;，格式为 YAML 格式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;

services:
  webapp:
    image: examples/web
    ports:
      - &amp;quot;80:80&amp;quot;
    volumes:
      - &amp;quot;/data&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意每个服务都必须通过 &lt;code&gt;image&lt;/code&gt; 指令指定镜像或 &lt;code&gt;build&lt;/code&gt; 指令（需要 Dockerfile）等来自动构建生成镜像。&lt;/p&gt;

&lt;p&gt;如果使用 &lt;code&gt;build&lt;/code&gt; 指令，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中设置的选项(例如：&lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;EXPOSE&lt;/code&gt;, &lt;code&gt;VOLUME&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt; 等) 将会自动被获取，无需在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中再次设置。&lt;/p&gt;

&lt;p&gt;下面分别介绍各个指令的用法。&lt;/p&gt;

&lt;h3 id=&#34;build-1:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 &lt;code&gt;Compose&lt;/code&gt; 将会利用它自动构建这个镜像，然后使用这个镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;3&#39;
services:

  webapp:
    build: ./dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以使用 &lt;code&gt;context&lt;/code&gt; 指令指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在文件夹的路径。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;dockerfile&lt;/code&gt; 指令指定 &lt;code&gt;Dockerfile&lt;/code&gt; 文件名。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;arg&lt;/code&gt; 指令指定构建镜像时的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;3&#39;
services:

  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;cache_from&lt;/code&gt; 指定构建镜像的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;build:
  context: .
  cache_from:
    - alpine:latest
    - corp/web_app:3.14
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cap-add-cap-drop:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;cap_add, cap_drop&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定容器的内核能力（capacity）分配。&lt;/p&gt;

&lt;p&gt;例如，让容器拥有所有能力可以指定为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cap_add:
  - ALL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去掉 NET_ADMIN 能力可以指定为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cap_drop:
  - NET_ADMIN
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;command:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;command&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;覆盖容器启动后默认执行的命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;command: echo &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configs:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;仅用于 &lt;code&gt;Swarm mode&lt;/code&gt;，详细内容请查看 &lt;a href=&#34;../swarm_mode/&#34;&gt;&lt;code&gt;Swarm mode&lt;/code&gt;&lt;/a&gt; 一节。&lt;/p&gt;

&lt;h3 id=&#34;cgroup-parent:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;cgroup_parent&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定父 &lt;code&gt;cgroup&lt;/code&gt; 组，意味着将继承该组的资源限制。&lt;/p&gt;

&lt;p&gt;例如，创建了一个 cgroup 组名称为 &lt;code&gt;cgroups_1&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cgroup_parent: cgroups_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;container-name:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;container_name&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定容器名称。默认将会使用 &lt;code&gt;项目名称_服务名称_序号&lt;/code&gt; 这样的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;container_name: docker-web-container
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;deploy:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;deploy&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;仅用于 &lt;code&gt;Swarm mode&lt;/code&gt;，详细内容请查看 &lt;a href=&#34;../swarm_mode/&#34;&gt;&lt;code&gt;Swarm mode&lt;/code&gt;&lt;/a&gt; 一节&lt;/p&gt;

&lt;h3 id=&#34;devices:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;devices&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定设备映射关系。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;devices:
  - &amp;quot;/dev/ttyUSB1:/dev/ttyUSB0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;depends-on:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;depends_on&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;解决容器的依赖、启动先后的问题。以下例子中会先启动 &lt;code&gt;redis&lt;/code&gt; &lt;code&gt;db&lt;/code&gt; 再启动 &lt;code&gt;web&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;3&#39;

services:
  web:
    build: .
    depends_on:
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;web&lt;/code&gt; 服务不会等待 &lt;code&gt;redis&lt;/code&gt; &lt;code&gt;db&lt;/code&gt; 「完全启动」之后才启动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;dns:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;dns&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;自定义 &lt;code&gt;DNS&lt;/code&gt; 服务器。可以是一个值，也可以是一个列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 114.114.114.114
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dns-search:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;dns_search&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;配置 &lt;code&gt;DNS&lt;/code&gt; 搜索域。可以是一个值，也可以是一个列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;dns_search: example.com

dns_search:
  - domain1.example.com
  - domain2.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tmpfs:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;tmpfs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;挂载一个 tmpfs 文件系统到容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tmpfs: /run
tmpfs:
  - /run
  - /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;env-file:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;env_file&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;从文件中获取环境变量，可以为单独的文件路径或列表。&lt;/p&gt;

&lt;p&gt;如果通过 &lt;code&gt;docker-compose -f FILE&lt;/code&gt; 方式来指定 Compose 模板文件，则 &lt;code&gt;env_file&lt;/code&gt; 中变量的路径会基于模板文件路径。&lt;/p&gt;

&lt;p&gt;如果有变量名称与 &lt;code&gt;environment&lt;/code&gt; 指令冲突，则按照惯例，以后者为准。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;环境变量文件中每一行必须符合格式，支持 &lt;code&gt;#&lt;/code&gt; 开头的注释行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# common.env: Set development environment
PROG_ENV=development
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;environment:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;environment&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;设置环境变量。你可以使用数组或字典两种格式。&lt;/p&gt;

&lt;p&gt;只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果变量名称或者值中用到 &lt;code&gt;true|false，yes|no&lt;/code&gt; 等表达 &lt;a href=&#34;https://yaml.org/type/bool.html&#34;&gt;布尔&lt;/a&gt; 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;expose:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;expose&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;暴露端口，但不映射到宿主机，只被连接的服务访问。&lt;/p&gt;

&lt;p&gt;仅可以指定内部端口为参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;expose:
 - &amp;quot;3000&amp;quot;
 - &amp;quot;8000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;external-links:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;external_links&lt;/code&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：不建议使用该指令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;链接到 &lt;code&gt;docker-compose.yml&lt;/code&gt; 外部的容器，甚至并非 &lt;code&gt;Compose&lt;/code&gt; 管理的外部容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;external_links:
 - redis_1
 - project_db_1:mysql
 - project_db_1:postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;extra-hosts:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;extra_hosts&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;类似 Docker 中的 &lt;code&gt;--add-host&lt;/code&gt; 参数，指定额外的 host 名称映射信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;extra_hosts:
 - &amp;quot;googledns:8.8.8.8&amp;quot;
 - &amp;quot;dockerhub:52.1.157.61&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会在启动后的服务容器中 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中添加如下两条条目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;8.8.8.8 googledns
52.1.157.61 dockerhub
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;healthcheck:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;healthcheck&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;通过命令检查容器是否健康运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;healthcheck:
  test: [&amp;quot;CMD&amp;quot;, &amp;quot;curl&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;http://localhost&amp;quot;]
  interval: 1m30s
  timeout: 10s
  retries: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;image:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;image&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定为镜像名称或镜像 ID。如果镜像在本地不存在，&lt;code&gt;Compose&lt;/code&gt; 将会尝试拉取这个镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;image: ubuntu
image: orchardup/postgresql
image: a4bc65fd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;labels:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;labels:
  com.startupteam.description: &amp;quot;webapp for a startup team&amp;quot;
  com.startupteam.department: &amp;quot;devops department&amp;quot;
  com.startupteam.release: &amp;quot;rc3 for v1.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;links:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;links&lt;/code&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：不推荐使用该指令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;logging:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;配置日志选项。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;logging:
  driver: syslog
  options:
    syslog-address: &amp;quot;tcp://192.168.0.42:123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前支持三种日志驱动类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;driver: &amp;quot;json-file&amp;quot;
driver: &amp;quot;syslog&amp;quot;
driver: &amp;quot;none&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;options&lt;/code&gt; 配置日志驱动的相关参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;options:
  max-size: &amp;quot;200k&amp;quot;
  max-file: &amp;quot;10&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;network-mode:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;network_mode&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;设置网络模式。使用和 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;--network&lt;/code&gt; 参数一样的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;network_mode: &amp;quot;bridge&amp;quot;
network_mode: &amp;quot;host&amp;quot;
network_mode: &amp;quot;none&amp;quot;
network_mode: &amp;quot;service:[service name]&amp;quot;
network_mode: &amp;quot;container:[container name/id]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;networks:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;networks&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;配置容器连接的网络。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;
services:

  some-service:
    networks:
     - some-network
     - other-network

networks:
  some-network:
  other-network:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pid:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;pid&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;pid: &amp;quot;host&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ports:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;ports&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;暴露端口信息。&lt;/p&gt;

&lt;p&gt;使用宿主端口：容器端口 &lt;code&gt;(HOST:CONTAINER)&lt;/code&gt; 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;ports:
 - &amp;quot;3000&amp;quot;
 - &amp;quot;8000:8000&amp;quot;
 - &amp;quot;49100:22&amp;quot;
 - &amp;quot;127.0.0.1:8001:8001&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;注意：当使用 &lt;code&gt;HOST:CONTAINER&lt;/code&gt; 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 &lt;code&gt;YAML&lt;/code&gt; 会自动解析 &lt;code&gt;xx:yy&lt;/code&gt; 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;secrets:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;存储敏感数据，例如 &lt;code&gt;mysql&lt;/code&gt; 服务密码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3.1&amp;quot;
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;security-opt:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;security_opt&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;security_opt:
    - label:user:USER
    - label:role:ROLE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stop-signal:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;stop_signal&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;stop_signal: SIGUSR1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sysctls:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;sysctls&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;配置容器内核参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;sysctls:
  net.core.somaxconn: 1024
  net.ipv4.tcp_syncookies: 0

sysctls:
  - net.core.somaxconn=1024
  - net.ipv4.tcp_syncookies=0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ulimits:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;ulimits&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;指定容器的 ulimits 限制值。&lt;/p&gt;

&lt;p&gt;例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  ulimits:
    nproc: 65535
    nofile:
      soft: 20000
      hard: 40000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;volumes:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;&lt;code&gt;volumes&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;数据卷所挂载路径设置。可以设置宿主机路径 （&lt;code&gt;HOST:CONTAINER&lt;/code&gt;） 或加上访问模式 （&lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;该指令中路径支持相对路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;volumes:
 - /var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其它指令:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;其它指令&lt;/h3&gt;

&lt;p&gt;此外，还有包括 &lt;code&gt;domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir&lt;/code&gt; 等指令，基本跟 &lt;code&gt;docker run&lt;/code&gt; 中对应参数的功能一致。&lt;/p&gt;

&lt;p&gt;指定服务容器启动后执行的入口文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;entrypoint: /code/entrypoint.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定容器中运行应用的用户名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;user: nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定容器中工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;working_dir: /code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定容器中搜索域名、主机名、mac 地址等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;domainname: your_website.com
hostname: test
mac_address: 08-00-27-00-0C-0A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;允许容器中运行一些特权命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;privileged: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 &lt;code&gt;always&lt;/code&gt; 或者 &lt;code&gt;unless-stopped&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;restart: always
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;read_only: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开标准输入，可以接受外部输入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;stdin_open: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模拟一个伪终端。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tty: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;读取变量:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;读取变量&lt;/h3&gt;

&lt;p&gt;Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 &lt;code&gt;.env&lt;/code&gt; 文件中的变量。&lt;/p&gt;

&lt;p&gt;例如，下面的 Compose 文件将从运行它的环境中读取变量 &lt;code&gt;${MONGO_VERSION}&lt;/code&gt; 的值，并写入执行的指令中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;
services:

db:
  image: &amp;quot;mongo:${MONGO_VERSION}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行 &lt;code&gt;MONGO_VERSION=3.2 docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:3.2&lt;/code&gt; 镜像的容器；如果执行 &lt;code&gt;MONGO_VERSION=2.8 docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:2.8&lt;/code&gt; 镜像的容器。&lt;/p&gt;

&lt;p&gt;若当前目录存在 &lt;code&gt;.env&lt;/code&gt; 文件，执行 &lt;code&gt;docker-compose&lt;/code&gt; 命令时将从该文件中读取变量。&lt;/p&gt;

&lt;p&gt;在当前目录新建 &lt;code&gt;.env&lt;/code&gt; 文件并写入以下内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 支持 # 号注释
MONGO_VERSION=3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行 &lt;code&gt;docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:3.6&lt;/code&gt; 镜像的容器。&lt;/p&gt;

&lt;h2 id=&#34;使用-django:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;使用 Django&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;本小节内容适合 &lt;code&gt;Python&lt;/code&gt; 开发人员阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们现在将使用 &lt;code&gt;Docker Compose&lt;/code&gt; 配置并运行一个 &lt;code&gt;Django/PostgreSQL&lt;/code&gt; 应用。&lt;/p&gt;

&lt;p&gt;在一切工作开始前，需要先编辑好三个必要的文件。&lt;/p&gt;

&lt;p&gt;第一步，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 &lt;code&gt;Dockerfile&lt;/code&gt; 文件来指定 Docker 容器要安装内容。内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM python:3
ENV PYTHONUNBUFFERED 1
RUN mkdir /code
WORKDIR /code
ADD requirements.txt /code/
RUN pip install -r requirements.txt
ADD . /code/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上内容指定应用将使用安装了 Python 以及必要依赖包的镜像。更多关于如何编写 &lt;code&gt;Dockerfile&lt;/code&gt; 文件的信息可以查看 &lt;a href=&#34;../image/create.md#利用 Dockerfile 来创建镜像&#34;&gt;镜像创建&lt;/a&gt; 和 &lt;a href=&#34;../dockerfile/README.md&#34;&gt; Dockerfile 使用&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;第二步，在 &lt;code&gt;requirements.txt&lt;/code&gt; 文件里面写明需要安装的具体依赖包名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Django&amp;gt;=1.8,&amp;lt;2.0
psycopg2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三步，&lt;code&gt;docker-compose.yml&lt;/code&gt; 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、使用的 Docker 镜像、镜像之间的连接、挂载到容器的卷，以及服务开放的端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;
services:

  db:
    image: postgres

  web:
    build: .
    command: python3 manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/code
    ports:
      - &amp;quot;8000:8000&amp;quot;
    links:
      - db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 &lt;a href=&#34;yml_ref.md&#34;&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt; 章节&lt;/a&gt; 了解更多详细的工作机制。&lt;/p&gt;

&lt;p&gt;现在我们就可以使用 &lt;code&gt;docker-compose run&lt;/code&gt; 命令启动一个 &lt;code&gt;Django&lt;/code&gt; 应用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run web django-admin.py startproject django_example .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compose 会先使用 &lt;code&gt;Dockerfile&lt;/code&gt; 为 web 服务创建一个镜像，接着使用这个镜像在容器里运行 &lt;code&gt;django-admin.py startproject django_example&lt;/code&gt; 指令。&lt;/p&gt;

&lt;p&gt;这将在当前目录生成一个 &lt;code&gt;Django&lt;/code&gt; 应用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls
Dockerfile       docker-compose.yml          django_example       manage.py       requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的系统是 Linux,记得更改文件权限。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo chown -R $USER:$USER .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，我们要为应用设置好数据库的连接信息。用以下内容替换 &lt;code&gt;django_example/settings.py&lt;/code&gt; 文件中 &lt;code&gt;DATABASES = ...&lt;/code&gt; 定义的节点内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.postgresql&#39;,
        &#39;NAME&#39;: &#39;postgres&#39;,
        &#39;USER&#39;: &#39;postgres&#39;,
        &#39;HOST&#39;: &#39;db&#39;,
        &#39;PORT&#39;: 5432,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些信息是在 &lt;a href=&#34;https://hub.docker.com/_/postgres/&#34;&gt;postgres&lt;/a&gt; 镜像固定设置好的。然后，运行 &lt;code&gt;docker-compose up&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up

django_db_1 is up-to-date
Creating django_web_1 ...
Creating django_web_1 ... done
Attaching to django_db_1, django_web_1
db_1   | The files belonging to this database system will be owned by user &amp;quot;postgres&amp;quot;.
db_1   | This user must also own the server process.
db_1   |
db_1   | The database cluster will be initialized with locale &amp;quot;en_US.utf8&amp;quot;.
db_1   | The default database encoding has accordingly been set to &amp;quot;UTF8&amp;quot;.
db_1   | The default text search configuration will be set to &amp;quot;english&amp;quot;.

web_1  | Performing system checks...
web_1  |
web_1  | System check identified no issues (0 silenced).
web_1  |
web_1  | November 23, 2017 - 06:21:19
web_1  | Django version 1.11.7, using settings &#39;django_example.settings&#39;
web_1  | Starting development server at http://0.0.0.0:8000/
web_1  | Quit the server with CONTROL-C.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 &lt;code&gt;Django&lt;/code&gt; 应用已经开始在你的 Docker 守护进程里监听着 &lt;code&gt;8000&lt;/code&gt; 端口了。打开 &lt;code&gt;127.0.0.1:8000&lt;/code&gt; 即可看到 &lt;code&gt;Django&lt;/code&gt; 欢迎页面。&lt;/p&gt;

&lt;p&gt;你还可以在 Docker 上运行其它的管理命令，例如对于同步数据库结构这种事，在运行完 &lt;code&gt;docker-compose up&lt;/code&gt; 后，在另外一个终端进入文件夹运行以下命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run web python manage.py syncdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用-rails:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;使用 Rails&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;本小节内容适合 &lt;code&gt;Ruby&lt;/code&gt; 开发人员阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们现在将使用 &lt;code&gt;Compose&lt;/code&gt; 配置并运行一个 &lt;code&gt;Rails/PostgreSQL&lt;/code&gt; 应用。&lt;/p&gt;

&lt;p&gt;在一切工作开始前，需要先设置好三个必要的文件。&lt;/p&gt;

&lt;p&gt;首先，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 &lt;code&gt;Dockerfile&lt;/code&gt; 文件来指定 Docker 容器要安装内容。内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM ruby
RUN apt-get update -qq &amp;amp;&amp;amp; apt-get install -y build-essential libpq-dev
RUN mkdir /myapp
WORKDIR /myapp
ADD Gemfile /myapp/Gemfile
RUN bundle install
ADD . /myapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上内容指定应用将使用安装了 Ruby、Bundler 以及其依赖件的镜像。更多关于如何编写 Dockerfile 文件的信息可以查看 &lt;a href=&#34;../image/create.md#利用 Dockerfile 来创建镜像&#34;&gt;镜像创建&lt;/a&gt; 和 &lt;a href=&#34;../dockerfile/README.md&#34;&gt;Dockerfile 使用&lt;/a&gt;。
下一步，我们需要一个引导加载 Rails 的文件 &lt;code&gt;Gemfile&lt;/code&gt; 。 等一会儿它还会被 &lt;code&gt;rails new&lt;/code&gt; 命令覆盖重写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source &#39;https://rubygems.org&#39;
gem &#39;rails&#39;, &#39;4.0.2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，&lt;code&gt;docker-compose.yml&lt;/code&gt; 文件才是最神奇的地方。 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、每个镜像的来源（数据库运行在使用预定义的 PostgreSQL 镜像，web 应用侧将从本地目录创建）、镜像之间的连接，以及服务开放的端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;
services:

  db:
    image: postgres
    ports:
      - &amp;quot;5432&amp;quot;

  web:
    build: .
    command: bundle exec rackup -p 3000
    volumes:
      - .:/myapp
    ports:
      - &amp;quot;3000:3000&amp;quot;
    links:
      - db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有文件就绪后，我们就可以通过使用 &lt;code&gt;docker-compose run&lt;/code&gt; 命令生成应用的骨架了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run web rails new . --force --database=postgresql --skip-bundle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 会先使用 &lt;code&gt;Dockerfile&lt;/code&gt; 为 web 服务创建一个镜像，接着使用这个镜像在容器里运行 &lt;code&gt;rails new&lt;/code&gt; 和它之后的命令。一旦这个命令运行完后，应该就可以看一个崭新的应用已经生成了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls
Dockerfile   app          docker-compose.yml      tmp
Gemfile      bin          lib          vendor
Gemfile.lock condocker-compose       log
README.rdoc  condocker-compose.ru    public
Rakefile     db           test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在新的 &lt;code&gt;Gemfile&lt;/code&gt; 文件去掉加载 &lt;code&gt;therubyracer&lt;/code&gt; 的行的注释，这样我们便可以使用 Javascript 运行环境：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem &#39;therubyracer&#39;, platforms: :ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们已经有一个新的 &lt;code&gt;Gemfile&lt;/code&gt; 文件，需要再重新创建镜像。（这个会步骤会改变 Dockerfile 文件本身，所以需要重建一次）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用现在就可以启动了，但配置还未完成。Rails 默认读取的数据库目标是 &lt;code&gt;localhost&lt;/code&gt; ，我们需要手动指定容器的 &lt;code&gt;db&lt;/code&gt; 。同样的，还需要把用户名修改成和 postgres 镜像预定的一致。
打开最新生成的 &lt;code&gt;database.yml&lt;/code&gt; 文件。用以下内容替换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;development: &amp;amp;default
  adapter: postgresql
  encoding: unicode
  database: postgres
  pool: 5
  username: postgres
  password:
  host: db

test:
  &amp;lt;&amp;lt;: *default
  database: myapp_test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以启动应用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切正常，你应该可以看到 PostgreSQL 的输出，几秒后可以看到这样的重复信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;myapp_web_1 | [2014-01-17 17:16:29] INFO  WEBrick 1.3.1
myapp_web_1 | [2014-01-17 17:16:29] INFO  ruby 2.0.0 (2013-11-22) [x86_64-linux-gnu]
myapp_web_1 | [2014-01-17 17:16:29] INFO  WEBrick::HTTPServer#start: pid=1 port=3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后， 我们需要做的是创建数据库，打开另一个终端，运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose run web rake db:create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 web 应用已经开始在你的 docker 守护进程里面监听着 3000 端口了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../_images/docker-compose-rails-screenshot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用-wordpress:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;使用 WordPress&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;本小节内容适合 &lt;code&gt;PHP&lt;/code&gt; 开发人员阅读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 可以很便捷的让 &lt;code&gt;Wordpress&lt;/code&gt; 运行在一个独立的环境中。&lt;/p&gt;

&lt;h3 id=&#34;创建空文件夹:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;创建空文件夹&lt;/h3&gt;

&lt;p&gt;假设新建一个名为 &lt;code&gt;wordpress&lt;/code&gt; 的文件夹，然后进入这个文件夹。&lt;/p&gt;

&lt;h3 id=&#34;创建-docker-compose-yml-文件:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;创建 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/yeasy/docker_practice/blob/master/compose/demo/wordpress/docker-compose.yml&#34;&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;&lt;/a&gt; 文件将开启一个 &lt;code&gt;wordpress&lt;/code&gt; 服务和一个独立的 &lt;code&gt;MySQL&lt;/code&gt; 实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &amp;quot;3&amp;quot;
services:

   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: somewordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - &amp;quot;8000:80&amp;quot;
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress
volumes:
  db_data:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构建并运行项目:e45b139cc9940b249d4f3ed1864fc2b3&#34;&gt;构建并运行项目&lt;/h3&gt;

&lt;p&gt;运行 &lt;code&gt;docker-compose up -d&lt;/code&gt; Compose 就会拉取镜像再创建我们所需要的镜像，然后启动 &lt;code&gt;wordpress&lt;/code&gt; 和数据库容器。 接着浏览器访问 &lt;code&gt;127.0.0.1:8000&lt;/code&gt; 端口就能看到 &lt;code&gt;WordPress&lt;/code&gt; 安装界面了。&lt;/p&gt;

&lt;p&gt;转至:&lt;a href=&#34;https://github.com/yeasy/docker_practice&#34;&gt;https://github.com/yeasy/docker_practice&lt;/a&gt;   d3c197ddfcc89aab5736b2a2eeb118f76e2588ba&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>